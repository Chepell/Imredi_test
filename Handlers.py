import numpy as np
import pandas as pd
from statsmodels.tsa.stattools import adfuller
import matplotlib.pyplot as plt
import seaborn as sns

import plotly.graph_objects as go
import plotly.offline as py


def plot_result_of_fillna(df, na_ind, title):
    """
    Plot a time series of orders, highlighting interpolated points.

    Parameters:
    - df (DataFrame): Data frame containing the 'Orders' column.
    - na_ind (Index): Index of the points that have been interpolated.
    - title (str): The title for the plot.

    Returns:
    - None
    """

    # Create the main plot for the 'Orders' column
    ax = df.plot(y="Orders", figsize=(10, 6), linewidth=1)

    # Highlight the interpolated points using blue circles
    highlight = df.loc[na_ind]
    highlight.plot(y="Orders", style="bo", markersize=2, ax=ax)

    # Add legend and title to the plot
    ax.legend(["Orders", "Interpolate Orders"])
    plt.title(title, size=14)

    # Save the plot as a PNG file
    plt.savefig("../pics/" + title + " fillna.png", dpi=300, bbox_inches="tight")

    # Display the plot
    plt.show()


def transform_for_prophet(df):
    """
    Transform the input DataFrame to be compatible with Facebook's Prophet model.

    Parameters:
    - df (DataFrame): Input DataFrame. The index should represent dates, and it should have one column for the values.

    Returns:
    - DataFrame: Transformed DataFrame with columns renamed to "ds" for date and "y" for the value.
    """

    # Reset the index so that date becomes a regular column
    new_df = df.reset_index()

    # Rename the columns to be compatible with Prophet
    new_df.columns = ["ds", "y"]

    return new_df


def get_format_forcast(forecast):
    """
    Transform the forecast DataFrame from Prophet to a format that aligns with the original data.

    Parameters:
    - forecast (DataFrame): The forecast DataFrame generated by Prophet.

    Returns:
    - DataFrame: Transformed DataFrame with only the 'yhat' column and column name changed to 'Orders'.
    """

    # Set the date ('ds') as the DataFrame index
    pred_df = forecast.set_index(keys="ds")

    # Set the frequency of the DataFrame index to Daily
    pred_df.index.freq = "D"

    # Keep only the 'yhat' column, which contains the forecasted values
    pred_df = pred_df[["yhat"]]

    # Convert the forecasted values to integers
    pred_df["yhat"] = pred_df["yhat"].astype(int)

    # Rename the column to 'Orders' to align with original data
    pred_df.columns = ["num_of_buyers"]

    return pred_df


def get_events_from_calendar(calendar_df, use_lockdown_info=True):
    """
    Extracts holiday, warm day, and Black Friday events from a calendar DataFrame
    and formats them for use with Prophet.

    Parameters:
    - calendar_df (DataFrame): The calendar DataFrame with columns 'day_id', 'is_holiday', 'is_warm', and 'is_black_friday'.
    - use_lockdown_info (bool): Whether to include COVID-19 related events in the output DataFrame.

    Returns:
    - DataFrame: A DataFrame containing all extracted and formatted events.
    """

    # Extract rows where each event type is true
    holiday_data = calendar_df[calendar_df["is_holiday"] == 1]
    warm_data = calendar_df[calendar_df["is_warm"] == 1]
    black_friday_data = calendar_df[calendar_df["is_black_friday"] == 1]

    # Create separate DataFrames for each event type
    prophet_holidays = pd.DataFrame(
        {"holiday": "holiday", "ds": holiday_data["day_id"]}
    )
    prophet_warm = pd.DataFrame({"holiday": "warm_day", "ds": warm_data["day_id"]})
    prophet_black_friday = pd.DataFrame(
        {"holiday": "black_friday", "ds": black_friday_data["day_id"]}
    )

    # Combine the event DataFrames
    all_events = pd.concat(
        [prophet_holidays, prophet_warm, prophet_black_friday], ignore_index=True
    )

    # Add COVID-19 related events if specified
    if use_lockdown_info:
        # Define COVID-19 related events and their durations
        covid_lockdown = pd.DataFrame(
            {
                "holiday": "lockdown",
                "ds": pd.to_datetime(["2020-03-30"]),
                "lower_window": 0,
                "upper_window": 123,
            }
        )
        covid_qr_restriction = pd.DataFrame(
            {
                "holiday": "qr_restriction",
                "ds": pd.to_datetime(["2021-06-12"]),
                "lower_window": 0,
                "upper_window": 49,
            }
        )
        covid_msk_lockdown = pd.DataFrame(
            {
                "holiday": "msk_lockdown",
                "ds": pd.to_datetime(["2021-10-26"]),
                "lower_window": 0,
                "upper_window": 17,
            }
        )

        # Add COVID-19 related events to the overall event DataFrame
        all_events = pd.concat(
            [all_events, covid_lockdown, covid_qr_restriction, covid_msk_lockdown],
            ignore_index=True,
        )

    return all_events


def plot_chart(df, pred, res_name):
    """
    Plot historical and predicted buyers using Plotly.

    Parameters:
    - df (DataFrame): DataFrame containing historical order data with 'buyers' as one of its columns.
    - pred (DataFrame): DataFrame containing predicted buyers.
    - res_name (str): Name of the restaurant for which the predictions are made.

    Outputs:
    - A Plotly chart saved as an HTML file.
    """

    # Create the title of the chart
    title = res_name + " Historical Orders and Predictions"

    # Define traces for the Plotly chart
    trace1 = go.Scatter(
        x=pred.index,
        y=pred["num_of_buyers"],
        name="Forecast 30 days",
        line=dict(color="red", width=1),
    )
    trace2 = go.Scatter(
        x=df.index, y=df["num_of_buyers"], name="num_of_buyers", line=dict(color="blue", width=1)
    )

    # Create layout for the Plotly chart
    layout = go.Layout(
        title=title,
        width=1000,
        height=700,
        margin=go.layout.Margin(l=10, r=10, b=10, t=40),
        legend=dict(
            x=0,
            y=1,
            traceorder="reversed",
            orientation="v",
        ),
    )

    # Generate the Plotly figure
    fig = go.Figure(data=[trace1, trace2], layout=layout)

    # Write the Plotly figure as an HTML file
    # fig.write_html("../pics/" + title + ".html")

    # Display the Plotly figure
    py.iplot(fig)


def outliers_iqr(df, feature, log_scale=False, left=1.5, right=1.5):
    """
    Identify outliers in a DataFrame based on the Interquartile Range (IQR) method.

    Parameters:
    - df (DataFrame): The DataFrame to analyze.
    - feature (str): The column name containing the feature for which to identify outliers.
    - log_scale (bool): Whether to use the log scale for calculations. Default is False.
    - left (float): Left multiplier for the IQR. Default is 1.5.
    - right (float): Right multiplier for the IQR. Default is 1.5.

    Returns:
    - Tuple:
        1. Info string describing the number of outliers found and the proportion to total data.
        2. DataFrame containing the outliers.
        3. DataFrame excluding the outliers.
    """

    # Extract the data column for the feature
    x = df[feature]

    # Apply log scaling if required
    if log_scale:
        x = np.log(x)

    # Calculate the first and third quartiles
    quartile_1, quartile_3 = x.quantile(0.25), x.quantile(0.75)

    # Compute the interquartile range (IQR)
    iqr = quartile_3 - quartile_1

    # Calculate bounds for the outliers
    lower_bound = quartile_1 - (iqr * left)
    upper_bound = quartile_3 + (iqr * right)

    # Identify outliers
    outliers_mask = (x < lower_bound) | (x > upper_bound)

    # Get DataFrame rows that are outliers and those that are not
    outliers = df[outliers_mask]
    cleaned = df[~outliers_mask]

    # Generate summary info
    info = f"Outliers: {len(outliers)} rows ({len(outliers) / len(df) * 100:.2f}%)."

    return info, outliers, cleaned


def save_pred(pred, rest_num):
    """
    Save the prediction DataFrame to a CSV file.

    Parameters:
    - pred (DataFrame): The DataFrame containing the predictions.
    - rest_num (int): The restaurant number, used as a key and in the file name.

    Returns:
    - None
    """

    # Reset the index to convert the index to a regular column
    pred_to_save = pred.reset_index()

    # Add a new 'key' column filled with the restaurant number
    pred_to_save["key"] = rest_num

    # Rename columns to desired names
    pred_to_save.columns = ["ds", "y", "key"]

    # Reorder columns
    pred_to_save = pred_to_save[["key", "ds", "y"]]

    # Save the DataFrame to a CSV file
    pred_to_save.to_csv(f"../data/pred_{rest_num:02}.csv", index=False)


def adf(x, threshold=0.05):
    """
    Perform Augmented Dickey-Fuller (ADF) test to check for stationarity.

    Parameters:
    - x (array-like): The time series data.
    - threshold (float): The significance level for the p-value.

    Prints:
    - Test statistic and p-value of the ADF test.
    - Conclusion about the stationarity of the time series.

    Returns:
    - None
    """

    # Calculate the test statistic and p-value using the ADF test
    _, pvalue = adfuller(x)[0], adfuller(x)[1]

    # Print the test statistic and p-value
    print("Test-Statistic:", _)
    print("P-Value:", pvalue)

    # Define the null and alternative hypotheses
    H0 = "Time series is non-stationary"
    Ha = "Time series is stationary!"

    # Evaluate the hypotheses based on the p-value
    if pvalue <= threshold:  # Reject the null hypothesis
        print(Ha)
    else:
        print(H0)


def plot_outliers_z_score(df, feature, log_scale=False, left=3, right=3):
    """
    Plot histograms of a feature, highlighting the outliers based on Z-score.

    Parameters:
    - df (DataFrame): The data frame containing the feature to plot.
    - feature (str): The name of the feature column in the DataFrame.
    - log_scale (bool): Whether to apply log transformation.
    - left (float): The left Z-score threshold for outlier detection.
    - right (float): The right Z-score threshold for outlier detection.

    Returns:
    - None
    """

    # Create subplots for the two histograms
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(18, 8))

    # Plot the histogram of the original feature
    sns.histplot(data=df, x=feature, ax=axes[0])

    # Extract the data for the feature
    x = df[feature]

    # Apply log transformation if specified
    if log_scale:
        if 0 in x:
            x = np.log(x + 1)  # Add 1 if the array contains zero.
        else:
            x = np.log(x)

    # Calculate the mean and standard deviation
    mu = x.mean()
    sigma = x.std()

    # Compute Z-score thresholds for outlier detection
    left_bound = mu - left * sigma
    right_bound = mu + right * sigma

    # Plot the histogram after transformation (if any)
    sns.histplot(data=x, ax=axes[1])

    # Plot vertical lines to indicate the mean and Z-score bounds
    axes[1].axvline(mu, color="k", lw=2)
    axes[1].axvline(left_bound, color="k", ls="--", lw=2)
    axes[1].axvline(right_bound, color="k", ls="--", lw=2)

    # Adjust layout and show plot
    plt.tight_layout()
    plt.show()


def box_and_hist_plots(df, feature):
    """
    Generate a combined plot with a box plot at the top
    and a histogram at the bottom for a given feature.

    Parameters:
    -----------
    df : DataFrame
        Input dataframe containing the data.
    feature : str
        The name of the column to visualize.

    Returns:
    --------
    None
        Displays the combined plot.
    """

    fig, ax = plt.subplots(
        2, figsize=(10, 6), sharex=True, gridspec_kw={"height_ratios": (0.50, 0.85)}
    )

    sns.boxplot(x=df[feature], ax=ax[0])
    sns.histplot(data=df, x=feature, kde=True, ax=ax[1])

    ax[0].set(xlabel="")
    ax[0].set_title(f"Box-Plot and Distribution for '{feature}'", fontsize=12)

    plt.ylabel("Count", fontsize=10)
    plt.xlabel("Class", fontsize=10)

    plt.xticks(fontsize=9)
    plt.yticks(fontsize=9)

    plt.tight_layout()
    plt.show()
